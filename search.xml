<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx 常用]]></title>
    <url>%2F2018%2F01%2F26%2Fnginx%2F</url>
    <content type="text"><![CDATA[CentOS 7 (使用yum进行安装)建议先替换CentOS 7阿里镜像地址12345678910#添加CentOS 7阿里镜像地址wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo或者curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo#安装Nginxsudo yum install -y nginx#启动Nginxsudo systemctl start nginx#CentOS 7 开机启动Nginxsudo systemctl enable nginx 常用配置 静态资源12345678910server &#123; server_name static.domain.com; root /app/static; index null; location / &#123; autoindex on; #是否开启索引 autoindex_exact_size on; autoindex_localtime on; &#125;&#125; 静态资源加认证12345678910111213141516#生成用户名密码printf &quot;hugo:$(openssl passwd -crypt 123456)\n&quot; &gt;&gt;/etc/nginx/user_file cat /etc/nginx/user_file#增加认证配置server &#123; server_name static.domain.com; root /app/static; index null; location / &#123; auth_basic &quot;Restricted&quot;; auth_basic_user_file /etc/nginx/user_file; autoindex on; #是否开启索引 autoindex_exact_size on; autoindex_localtime on; &#125;&#125; 代理支持ws1234567891011121314server &#123; server_name ws.domain.com; location / &#123; proxy_redirect off; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $remote_addr; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://127.0.0.1:8080; &#125;&#125; 配置https证书123456789101112131415161718192021222324server &#123; server_name test.domain.com; location ^~ /.well-known/acme-challenge/ &#123; default_type &quot;text/plain&quot;; root /usr/share/nginx/html; &#125; location / &#123; return 301 https://test.domain.com$request_uri; &#125;&#125;server &#123; server_name test.domain.com; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/test.domain.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/test.domain.com/privkey.pem; location / &#123; proxy_pass https://192.168.99.100:31808; &#125;&#125; upstream 五种分配方式1、轮询(weight=1) 默认选项，当weight不指定时，各服务器weight相同，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234upstream testapi &#123; server 192.168.1.61:8085; server 192.168.1.62:8085;&#125; 2、weight 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。如果后端服务器down掉，能自动剔除。例如以下配置，则62服务器的访问量为61服务器的两倍。1234upstream testapi &#123; server 192.168.1.61:8085 weight=1; server 192.168.1.62:8085 weight=2;&#125; 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。如果后端服务器down掉，要手工down掉。12345upstream testapi &#123; ip_hash; server 192.168.1.61:8085; server 192.168.1.62:8085;&#125; 4、fair（第三方插件） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。12345upstream testapi &#123; server 192.168.1.61:8085; server 192.168.1.62:8085; fair;&#125; 5、url_hash（第三方插件） 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器时比较有效。在upstream中加入hash语句，hash_method是使用的hash算法。 123456upstream testapi &#123; server 192.168.1.61:8085; server 192.168.1.62:8085; hash $request_uri; hash_method crc32;&#125; 下面来看一个负载均衡示例：1234567891011121314151617upstream testapi &#123;#ip_hash;server 192.168.1.61:8085;server 192.168.1.62:8085 weight=100 down;server 192.168.1.63:8085 weight=100;server 192.168.1.64:8085 weight=100 backup;server 192.168.1.65:8085 weight=100 max_fails=3 fail_timeout=30s;&#125;server &#123; server_name test.domain.com; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://testapi; &#125;&#125; 示例说明: down 表示当前的server暂时不参与负载 weight 默认为1.weight越大，负载的权重就越大。 backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 上例中192.168.1.65:8085设置最大失败次数为 3，也就是最多进行 3 次尝试，且超时时间为 30秒。max_fails 的默认值为 1，fail_timeout 的默认值是 10s。 注意： 当upstream中只有一个server时，max_fails 和 fail_timeout 参数可能不会起作用。 weight\backup不能和ip_hash关键字一起使用。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Let's Encrypt给网站免费加上https]]></title>
    <url>%2F2018%2F01%2F26%2FLet-sEncrypt%2F</url>
    <content type="text"><![CDATA[推荐，acme.shacme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书. 主要步骤: 安装 acme.sh 生成证书 copy 证书到 nginx/apache 或者其他服务 更新证书 更新 acme.sh 出错怎么办, 如何调试 下面详细介绍. 1. 安装 acme.sh安装很简单, 一个命令:1curl https://get.acme.sh | sh 普通用户和 root 用户都可以安装使用.安装过程进行了以下几步: 1) 把 acme.sh 安装到你的 home 目录下: 1~/.acme.sh/ 并创建 一个 bash 的 alias, 方便你的使用: acme.sh=~/.acme.sh/acme.sh 2). 自动为你创建 cronjob, 每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书. 更高级的安装选项请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-install 安装过程不会污染已有的系统任何功能和文件, 所有的修改都限制在安装目录中: ~/.acme.sh/ 2. 生成证书acme.sh 实现了 acme 协议支持的所有验证协议.一般有两种方式验证: http 和 dns 验证. 1. http 方式需要在你的网站根目录下放置一个文件, 来验证你的域名所有权,完成验证. 然后就可以生成证书了.1acme.sh --issue -d mydomain.com -d www.mydomain.com --webroot /home/wwwroot/mydomain.com/ 只需要指定域名, 并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用. 如果你用的 apache服务器, acme.sh 还可以智能的从 apache的配置中自动完成验证, 你不需要指定网站根目录:1acme.sh --issue -d mydomain.com --apache 如果你用的 nginx服务器, 或者反代, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 你不需要指定网站根目录:1acme.sh --issue -d mydomain.com --nginx 注意, 无论是 apache 还是 nginx 模式, acme.sh在完成验证之后, 会恢复到之前的状态, 都不会私自更改你本身的配置. 好处是你不用担心配置被搞坏, 也有一个缺点, 你需要自己配置 ssl 的配置, 否则只能成功生成证书, 你的网站还是无法访问https. 但是为了安全, 你还是自己手动改配置吧. 如果你还没有运行任何 web 服务, 80 端口是空闲的, 那么 acme.sh 还能假装自己是一个webserver, 临时听在80 端口, 完成验证: 1acme.sh --issue -d mydomain.com --standalone 更高级的用法请参考: https://github.com/Neilpang/acme.sh/wiki/How-to-issue-a-cert 2. dns 方式, 在域名上添加一条 txt 解析记录, 验证域名所有权.这种方式的好处是, 你不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证.坏处是，如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书，每次都需要手动再次重新解析验证域名所有权。 1acme.sh --issue --dns -d mydomain.com 然后, acme.sh 会生成相应的解析记录显示出来, 你只需要在你的域名管理面板中添加这条 txt 记录即可. 等待解析完成之后, 重新生成证书:1acme.sh --renew -d mydomain.com 注意第二次这里用的是 --renew dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证. acme.sh 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成. 以 dnspod 为例, 你需要先登录到 dnspod 账号, 生成你的 api id 和 api key, 都是免费的.然后:12345export DP_Id=&quot;1234&quot;export DP_Key=&quot;sADDsdasdgdsf&quot;acme.sh --issue --dns dns_dp -d aa.com -d www.aa.com 证书就会自动生成了. 这里给出的 api id 和 api key 会被自动记录下来, 将来你在使用 dnspod api 的时候, 就不需要再次指定了.直接生成就好了: 1acme.sh --issue -d mydomain2.com --dns dns_dp 更详细的 api 用法: https://github.com/Neilpang/acme.sh/blob/master/dnsapi/README.md 3. copy/安装 证书前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方. 注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化. 正确的使用方法是使用 --installcert 命令,并指定目标位置, 然后证书文件会被copy到相应的位置,例如:1234acme.sh --installcert -d &lt;domain&gt;.com \ --key-file /etc/nginx/ssl/&lt;domain&gt;.key \ --fullchain-file /etc/nginx/ssl/fullchain.cer \ --reloadcmd &quot;service nginx force-reload&quot; (一个小提醒, 这里用的是 service nginx force-reload, 不是 service nginx reload, 据测试, reload 并不会重新加载证书, 所以用的 force-reload) Nginx 的配置 ssl_certificate 使用 /etc/nginx/ssl/fullchain.cer ，而非 /etc/nginx/ssl/&lt;domain&gt;.cer ，否则 SSL Labs 的测试会报 Chain issues Incomplete 错误。 --installcert命令可以携带很多参数, 来指定目标文件. 并且可以指定 reloadcmd, 当证书更新以后, reloadcmd会被自动调用,让服务器生效. 详细参数请参考: https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc 值得注意的是, 这里指定的所有参数都会被自动记录下来, 并在将来证书自动更新以后, 被再次自动调用. 4. 更新证书目前证书在 60 天以后会自动更新, 你无需任何操作. 今后有可能会缩短这个时间, 不过都是自动的, 你不用关心. 5. 更新 acme.sh目前由于 acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步. 升级 acme.sh 到最新版 :1acme.sh --upgrade 如果你不想手动升级, 可以开启自动升级: 1acme.sh --upgrade --auto-upgrade 之后, acme.sh 就会自动保持更新了. 你也可以随时关闭自动更新: 1acme.sh --upgrade --auto-upgrade 0 6. 出错怎么办：如果出错, 请添加 debug log： 1acme.sh --issue ..... --debug 或者：1acme.sh --issue ..... --debug 2 请参考： https://github.com/Neilpang/acme.sh/wiki/How-to-debug-acme.sh 最后, 本文并非完全的使用说明, 还有很多高级的功能, 更高级的用法请参看其他 wiki 页面. https://github.com/Neilpang/acme.sh/wiki 以上内容引用：https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker 入门]]></title>
    <url>%2F2017%2F12%2F30%2Fdocker%2F</url>
    <content type="text"><![CDATA[docker常用命令1234567891011121314151617杀死所有正在运行的容器docker kill $(docker ps -a -q)停止所有正在运行的容器docker stop $(docker ps -a -q)删除所有已经停止的容器docker rm $(docker ps -a -q)删除所有未打 dangling 标签的镜像docker rmi $(docker images -q -f dangling=true)删除所有镜像docker rmi $(docker images -q)强制删除镜像名称中包含“doss-api”的镜像docker rmi --force $(docker images | grep doss-api | awk &apos;&#123;print $3&#125;&apos;) https://docs.docker.com/engine/installation/linux/centos/ 安装安装链接 https://yq.aliyun.com/articles/110806 CentOS 7 (使用yum进行安装)1234567891011121314151617181920212223242526# step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# Step 2: 添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# Step 3: 更新并安装 Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo service docker start# 注意：# 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。# vim /etc/yum.repos.d/docker-ee.repo# 将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1## 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# yum list docker-ce.x86_64 --showduplicates | sort -r# Loading mirror speeds from cached hostfile# Loaded plugins: branch, fastestmirror, langpacks# docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable# docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable# docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable# Available Packages# Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)# sudo yum -y install docker-ce-[VERSION] 添加阿里registry-mirrors1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;: [&quot;https://ot2cw52a.mirror.aliyuncs.com&quot;]&#125;EOFsudo cat /etc/docker/daemon.jsonsudo systemctl daemon-reloadsudo systemctl restart dockerdocker versiondocker info]]></content>
      <categories>
        <category>容器</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
